use std::str::FromStr;
use std::sync::Arc;
use ast::{BinaryOperator, Expression, Literal, NameType, Type};
use lalrpop_util::ErrorRecovery;

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, (usize, &'input str), ()>>);

match {
    r"#[^\n]*"
} else {
    _
}

Comment: () = {
    r"#[^\n]*"
};

Number: i32 = {
    // Base 10
    <s:r"[0-9]+"> => i32::from_str(s).unwrap(),
    // Base 16
    <s:r"0x[0-9A-Fa-f]+"> => i32::from_str_radix(&s[2..], 16).unwrap(),
};

Str: Arc<String> = {
    r"\x22(?:[^\x22\\]|\\.)*\x22" => {
        let val = <>;
        let len = val.len();
        Arc::new(String::from_str(&val[1..len-1]).unwrap())
    }
};

Literal: Literal = {
    Number => Literal::Int(<>),
    Str => Literal::Str(<>),
};

Name: Arc<String> = {
    r"[a-zA-Z_][\w]*" => Arc::new(String::from_str(<>).unwrap())
};

Type: Type = {
    "u8" => Type::U8,
    "u16" => Type::U16,
    "void" => Type::Void,
};

NameType: NameType = {
    <n:Name> ":" <t:Type> => NameType { name: n, type_name: t },
};

ParameterList: Vec<NameType> = {
    <l:ParameterList> "," <p:NameType> => {
        let mut result = l;
        result.push(p);
        result
    },
    NameType => vec![<>],
};

ComparisonOp: BinaryOperator = {
    "<" => BinaryOperator::LessThan,
    ">" => BinaryOperator::GreaterThan,
    "<=" => BinaryOperator::LessThanEqual,
    ">=" => BinaryOperator::GreaterThanEqual,
    "==" => BinaryOperator::Equal,
    "!=" => BinaryOperator::NotEqual,
};

Comparison: Box<Expression> = {
    <l:Comparison> <o:ExprOp> <r:Factor> => Box::new(Expression::BinaryOp { op: o, left: l, right: r }),
    Factor,
};

ExprOp: BinaryOperator = {
    "+" => BinaryOperator::Add,
    "-" => BinaryOperator::Sub,
};

Factor: Box<Expression> = {
    <l:Factor> <o:FactorOp> <r:Term> => Box::new(Expression::BinaryOp { op: o, left: l, right: r }),
    Term,
};

FactorOp: BinaryOperator = {
    "*" => BinaryOperator::Mul,
    "/" => BinaryOperator::Div,
};

Term: Box<Expression> = {
    Number => Box::new(Expression::Number(<>)),
    Name => Box::new(Expression::Name(<>)),
    "(" <Expression> ")",
};

FunctionCall: Box<Expression> = {
    <n:Name> "(" ")" => Box::new(Expression::CallFunction {
        name: n,
        arguments: Vec::new(),
    }),
    <n:Name> "(" <args:ExpressionCommaList> ")" => Box::new(Expression::CallFunction {
        name: n,
        arguments: args,
    }),
};

Expression: Box<Expression> = {
    <l:Expression> <o:ComparisonOp> <r:Comparison> => Box::new(Expression::BinaryOp { op: o, left: l, right: r }),
    Comparison,
    FunctionCall,
};

ExpressionCommaList: Vec<Expression> = {
    <l:ExpressionCommaList> "," <e:Expression> => {
        let mut result = l;
        result.push(*e);
        result
    },
    Expression => vec![*<>],
};

Statement: Box<Expression> = {
    Comment => Box::new(Expression::Comment),
    "const" <nt:NameType> "=" <l:Expression> ";" => Box::new(Expression::DeclareConst { name_type: nt, value: l }),
    "var" <nt:NameType> "=" <l:Expression> ";" => Box::new(Expression::DeclareVariable { name_type: nt, value: l }),
    <n:Name> "=" <l:Expression> ";" => Box::new(Expression::Assignment { name: n, value: l }),
    "left_shift" <n:Name> ";" => Box::new(Expression::LeftShift(n)),
    "rotate_left" <n:Name> ";" => Box::new(Expression::RotateLeft(n)),
    "rotate_right" <n:Name> ";" => Box::new(Expression::RotateRight(n)),
    "break" ";" => Box::new(Expression::Break),
    "return" <v:Expression> ";" => Box::new(Expression::Return { value: v }),
    "goto" <n:Name> ";" => Box::new(Expression::GoTo(n)),
    <f:FunctionCall> ";" => f,
    ! => {
        errors.push(<>);
        Box::new(Expression::Error)
    },
};

StatementList: Vec<Expression> = {
    <l:StatementList> <s:Statement> => {
        let mut result = l;
        result.push(*s);
        result
    },
    Statement => vec![*<>],
};

TopLevelStatement: Box<Expression> = {
    "org" <n:Number> ";" => Box::new(Expression::Org { org: n }),
    "register" <nt:NameType> "@" <l:Number> ";" => Box::new(Expression::DeclareRegister {
        name_type: nt,
        location: l,
    }),
    "def" <n:Name> "(" ")" ":" <rt:Type> <b:StatementList> "end" => Box::new(Expression::DeclareFunction {
        name: n,
        parameters: Vec::new(),
        return_type: rt,
        body: b,
    }),
    "def" <n:Name> "(" <pl:ParameterList> ")" ":" <rt:Type> <b:StatementList> "end" => Box::new(Expression::DeclareFunction {
        name: n,
        parameters: pl,
        return_type: rt,
        body: b,
    }),
    Statement,
};

pub Program: Vec<Expression> = {
    <p:Program> <tl:TopLevelStatement> => {
        let mut result = p;
        result.push(*tl);
        result
    },
    TopLevelStatement => vec![*<>],
};
