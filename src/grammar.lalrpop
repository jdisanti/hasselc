use std::str::FromStr;
use tokens::{Constant, Expr, Keyword, NameType, Operator, Program, Type};

grammar;

pub KeywordBreak: Keyword = { "break" => Keyword::Break, };
pub KeywordOrg: Keyword = { "org" => Keyword::Org, };
pub KeywordConst: Keyword = { "const" => Keyword::Const, };
pub KeywordDef: Keyword = { "def" => Keyword::Def, };
pub KeywordEnd: Keyword = { "end" => Keyword::End, };
pub KeywordFor: Keyword = { "for" => Keyword::For, };
pub KeywordIn: Keyword = { "in" => Keyword::In, };
pub KeywordTo: Keyword = { "to" => Keyword::To, };
pub KeywordLeftShift: Keyword = { "left_shift" => Keyword::LeftShift, };
pub KeywordRotateLeft: Keyword = { "rotate_left" => Keyword::RotateLeft, };
pub KeywordRotateRight: Keyword = { "rotate_right" => Keyword::RotateRight, };
pub KeywordReturn: Keyword = { "return" => Keyword::Return, };

pub operator: Operator = {
    "==" => Operator::EqualTo,
    ">=" => Operator::GreaterThanEqualTo,
    "<=" => Operator::LessThanEqualTo,
    ">" => Operator::GreaterThan,
    "<" => Operator::LessThan,
    "+" => Operator::Add,
    "-" => Operator::Subtract,
    "=" => Operator::Assign,
};

Base10Number: i32 = <s:r"[0-9]+"> => i32::from_str(s).unwrap();
Base16Number: i32 = <s:r"0x[0-9A-Fa-f]+"> => i32::from_str_radix(&s[2..], 16).unwrap();

pub Number: i32 = {
    <n:Base10Number> => n,
    <n:Base16Number> => n,
};

pub Text: String = {
    r"\x22(?:[^\x22\\]|\\.)*\x22" => {
        let val = <>;
        let len = val.len();
        String::from_str(&val[1..len-1]).unwrap()
    }
};

pub Name: String = {
    r"[a-zA-Z_][\w]*" => String::from_str(<>).unwrap()
};

pub Constant: Constant = {
    <n:Number> => Constant::Integer(n),
    <s:Text> => Constant::Text(s),
};

pub Command: Expr = {
    <b:KeywordBreak> => Expr::Command(b),
};

pub PrimitiveType: Type = {
    "u8" => Type::U8,
    "u16" => Type::U16,
    "ptr" => Type::Ptr,
    "void" => Type::Void,
};

pub NameType: NameType = {
    <n:Name> ":" <t:PrimitiveType> => NameType(n, t),
};

pub ParameterList: Vec<NameType> = {
    <l:ParameterList> "," <p:NameType> => {
        let mut result = l;
        result.push(p);
        result
    },
    NameType => vec![<>],
};

pub ReturnStatement: Expr = {
    <r:KeywordReturn> => Expr::Return(Box::from(Expr::Void)),
    <r:KeywordReturn> <n:Name> => Expr::Return(Box::from(Expr::Name(n))),
    <r:KeywordReturn> <c:Constant> => Expr::Return(Box::from(Expr::ConstantValue(c))),
};

pub SimpleExpression: Expr = {
    <c:Command> ";" => c,
    <o:KeywordOrg> <n:Number> ";" => Expr::Org(n),
    <c:KeywordConst> <n:Name> "=" <k:Constant> ";" => Expr::DeclareConst { name: n, value: k },
    <k:KeywordLeftShift> <n:Name> ";" => Expr::CommandOnName(k, n),
    <k:KeywordRotateLeft> <n:Name> ";" => Expr::CommandOnName(k, n),
    <k:KeywordRotateRight> <n:Name> ";" => Expr::CommandOnName(k, n),
    <r:ReturnStatement> ";" => r,
};

pub StructuralExpression: Expr = {
    // Empty for loop
    <k1:KeywordFor> <nt:NameType> <k2:KeywordIn> <r1:Constant> <k3:KeywordTo> <r2:Constant> <k4:KeywordEnd> => {
        Expr::ForLoop {
            index: nt,
            start: r1,
            finish: r2,
            body: Vec::new(),
        }
    },
    // For loop with a body
    <k1:KeywordFor> <nt:NameType> <k2:KeywordIn> <r1:Constant> <k3:KeywordTo> <r2:Constant> <b:ExpressionList> <k4:KeywordEnd> => {
        Expr::ForLoop {
            index: nt,
            start: r1,
            finish: r2,
            body: b,
        }
    },
};

pub ExpressionList: Vec<Expr> = {
    <e:ExpressionList> <e2:SimpleExpression> => {
        let mut result = e;
        result.push(e2);
        result
    },
    <e:ExpressionList> <e2:StructuralExpression> => {
        let mut result = e;
        result.push(e2);
        result
    },
    StructuralExpression => vec![<>],
    SimpleExpression => vec![<>],
};

pub FunctionDeclaration: Expr = {
    <d:KeywordDef> <n:Name> "(" <v:ParameterList> ")" ":" <r:PrimitiveType> => {
        Expr::DeclareFunction { name: n, parameters: v, return_type: r }
    }
};

pub Function: Expr = {
    // Empty function
    <d:FunctionDeclaration> <e:KeywordEnd> => {
        Expr::Function {
            declaration: Box::from(d),
            body: Vec::new(),
        }
    },
    // Function with a body
    <d:FunctionDeclaration> <el:ExpressionList> <e:KeywordEnd> => {
        Expr::Function {
            declaration: Box::from(d),
            body: el,
        }
    },
};

pub program: Program = {
    <p:program> <f:Function> => {
        let mut program = p;
        program.0.push(f);
        program
    },
    <el:ExpressionList> => Program(el),
};